{
  parserClass="parser.CobolParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Cobol"
  psiImplClassSuffix="Impl"
  psiPackage="psi"
  psiImplPackage="psi.impl"

  elementTypeHolderClass="psi.CobolTypes"
  elementTypeClass="psi.CobolElementType"
  tokenTypeClass="psi.CobolTokenType"
}

CobolWord	::=	COBOL_WORD

IntegerConstant	::=	LEVEL_66
|	LEVEL_77
|	LEVEL_88
|	LEVEL_NUMBER
|	INTEGER

NumericConstant	::=	( PLUSCHAR | MINUSCHAR )? IntegerConstant ( DOTCHAR IntegerConstant )?

LevelNumber	::=	LEVEL_NUMBER

FigurativeConstant	::=	ZERO
|	ZEROS
|	ZEROES
|	SPACE
|	SPACES
|	HIGH_VALUE
|	HIGH_VALUES
|	LOW_VALUE
|	LOW_VALUES
|	QUOTE
|	QUOTES
|	NULL
|	NULLS

NonNumericConstant	::=	( ( QUOTEDSTRING )+ | HEXNUMBER )

Literal	::=	( ALL )? ( NonNumericConstant | NumericConstant | FigurativeConstant )

Condition	::=	CombinableCondition ( ( AND | OR ) ( CombinableCondition | AbbreviationRest ) )*

CombinableCondition	::=	( NOT )? SimpleCondition

SimpleCondition	::=	( LPARENCHAR Condition RPARENCHAR | RelationCondition | ClassCondition | ConditionNameCondition )

ClassCondition	::=	Identifier ( IS )? ( NOT )? ( NUMERIC | ALPHABETIC | ALPHABETIC_LOWER | ALPHABETIC_UPPER | ClassName | DBCS | KANJI )

ConditionNameCondition	::=	ConditionNameReference

RelationCondition	::=	ArithmeticExpression ( RelationalOperator ArithmeticExpression | SignCondition )

SignCondition	::=	( IS )? ( NOT )? ( POSITIVE | NEGATIVE | ZERO )

RelationalOperator	::=	( IS )? ( ( NOT )? ( GREATER ( THAN )? | MORETHANCHAR | LESS ( THAN )? | LESSTHANCHAR | EQUAL ( TO )? | EQUALCHAR ) | GREATER ( THAN )? OR EQUAL ( TO )? | MORETHANOREQUAL | LESS ( THAN )? OR EQUAL ( TO )? | LESSTHANOREQUAL )

AbbreviationRest	::=	( ( NOT )? ( RelationalOperator )? AbbreviationLeaf )+

AbbreviationLeaf	::=	( ArithmeticExpression | LPARENCHAR ArithmeticExpression AbbreviationRest RPARENCHAR )

ProcedureName	::=	( ParagraphName ( ( IN | OF ) SectionName )? | SectionName )

Identifier	::=	( QualifiedDataName ( LPARENCHAR Subscript RPARENCHAR )* ( LPARENCHAR LeftmostCharacterPosition COLONCHAR ( Length )? RPARENCHAR )? | LINAGE_COUNTER ( ( IN | OF ) FileName )? )

QualifiedDataName	::=	( DataName ( ( IN | OF ) DataName )* ( ( IN | OF ) FileName )? | SpecialRegister )

Length	::=	ArithmeticExpression

LeftmostCharacterPosition	::=	ArithmeticExpression

ConditionNameReference	::=	ConditionName ( ( ( IN | OF ) DataName )* ( ( IN | OF ) FileName )? ( LPARENCHAR Subscript RPARENCHAR )* | ( ( IN | OF ) MnemonicName )* )

Subscript	::=	( IntegerConstant | QualifiedDataName ( ( PLUSCHAR | MINUSCHAR ) IntegerConstant )? | IndexName ( ( PLUSCHAR | MINUSCHAR ) IntegerConstant )? )+

Mode	::=	CobolWord

AlphabetName	::=	CobolWord

ClassName	::=	CobolWord

ConditionName	::=	CobolWord

DataName	::=	CobolWord

FileName	::=	CobolWord

IndexName	::=	CobolWord

MnemonicName	::=	CobolWord

RecordName	::=	QualifiedDataName

RoutineName	::=	CobolWord

SymbolicCharacter	::=	CobolWord

LibraryName	::=	CobolWord

ProgramName	::=	CobolWord

SectionName	::=	CobolWord

ParagraphName	::=	CobolWord

SystemName	::=	CobolWord

ComputerName	::=	SystemName

LanguageName	::=	SystemName

EnvironmentName	::=	SystemName

AssignmentName	::=	SystemName

BasisName	::=	ProgramName

SpecialRegister	::=	( ADDRESS OF DataName | DEBUG_ITEM | LENGTH OF Identifier | RETURN_CODE | SHIFT_OUT | SHIFT_IN | SORT_CONTROL | SORT_CORE_SIZE | SORT_FILE_SIZE | SORT_MESSAGE | SORT_MODE_SIZE | SORT_RETURN | TALLY | WHEN_COMPILED )

ArithmeticExpression	::=	TimesDiv ( ( PLUSCHAR | MINUSCHAR ) TimesDiv )*

TimesDiv	::=	Power ( ( ASTERISKCHAR | SLASHCHAR ) Power )*

Power	::=	( ( PLUSCHAR | MINUSCHAR ) )? Basis ( "**" Basis )*

Basis	::=	( Identifier | Literal | LPARENCHAR ArithmeticExpression RPARENCHAR )

CommentLine	::=	( ( ( COBOL_WORD )+ | QUOTEDSTRING ) DOT )+

CompilationUnit	::=	ProgramUnit ( NestedProgramUnit EndProgramStatement )* ( EndProgramStatement ( CompilationUnit )* )? EOF

ProgramUnit	::=	IdentificationDivision ( EnvironmentDivision )? ( DataDivision )? ( ProcedureDivision )?

NestedProgramUnit	::=	NestedIdentificationDivision ( EnvironmentDivision )? ( DataDivision )? ( ProcedureDivision )?

EndProgramStatement	::=	END PROGRAM ProgramName DOT

IdentificationDivision	::=	IDENTIFICATION DIVISION DOT ProgramIdParagraph ( IdentificationDivisionParagraph )*

NestedIdentificationDivision	::=	( IDENTIFICATION | ID ) DIVISION DOT NestedProgramIdParagraph ( IdentificationDivisionParagraph )*

IdentificationDivisionParagraph	::=	AuthorParagraph
|	InstallationParagraph
|	DateWrittenParagraph
|	DateCompiledParagraph
|	SecurityParagraph

ProgramIdParagraph	::=	PROGRAM_ID DOT ProgramName ( ( IS )? INITIAL ( PROGRAM )? )? DOT

NestedProgramIdParagraph	::=	PROGRAM_ID DOT ProgramName ( ( IS )? InitialOrCommon ( PROGRAM )? )? DOT

InitialOrCommon	::=	( INITIAL ( COMMON )? | COMMON ( INITIAL )? )

AuthorParagraph	::=	AUTHOR DOT ( CommentLine )?

InstallationParagraph	::=	INSTALLATION DOT ( CommentLine )?

DateWrittenParagraph	::=	DATE_WRITTEN DOT ( CommentLine )?

DateCompiledParagraph	::=	DATE_COMPILED DOT ( CommentLine )?

SecurityParagraph	::=	SECURITY DOT ( CommentLine )?

EnvironmentDivision	::=	ENVIRONMENT DIVISION DOT ( EnvironmentSection )*

EnvironmentSection	::=	ConfigurationSection
|	InputOutputSection

ConfigurationSection	::=	CONFIGURATION SECTION DOT ( ConfigurationSectionParagraph )*

ConfigurationSectionParagraph	::=	SourceComputerParagraph
|	ObjectComputerParagraph
|	SpecialNamesParagraph

SourceComputerParagraph	::=	SOURCE_COMPUTER DOT ComputerName ( ( WITH )? DEBUGGING MODE )? DOT

ObjectComputerParagraph	::=	OBJECT_COMPUTER DOT ComputerName ( ObjectComputerClause )* DOT

ObjectComputerClause	::=	MemorySizeClause
|	CollatingSequenceClause
|	SegmentLimitClause
|	CharacterSetClause

MemorySizeClause	::=	MEMORY ( SIZE )? IntegerConstant ( WORDS | CHARACTERS | MODULES )?

CollatingSequenceClause	::=	( PROGRAM )? ( COLLATING )? SEQUENCE ( IS )? AlphabetName

SegmentLimitClause	::=	SEGMENT LIMIT ( IS )? IntegerConstant

CharacterSetClause	::=	CHARACTER SET ( CommentLine )?

SpecialNamesParagraph	::=	SPECIAL_NAMES DOT ( SpecialNameClause ( SpecialNameClause )* DOT )?

SpecialNameClause	::=	AlphabetClause
|	ClassClause
|	CurrencySignClause
|	DecimalPointClause
|	SymbolicCharactersClause
|	EnvironmentNameIsMnemonicNameClause

AlphabetClause	::=	ALPHABET AlphabetName ( IS )? ( STANDARD_1 | STANDARD_2 | NATIVE | CobolWord | ( Literal ( ( ( THROUGH | THRU ) Literal | ( ALSO Literal )+ ) )? )+ )

ClassClause	::=	CLASS ClassName ( IS )? ( Literal ( ( THROUGH | THRU ) Literal )? )+

CurrencySignClause	::=	CURRENCY ( SIGN )? ( IS )? Literal

DecimalPointClause	::=	DECIMAL_POINT ( IS )? COMMA

SymbolicCharactersClause	::=	SYMBOLIC ( CHARACTERS )? ( ( SymbolicCharacter )+ ( ( ARE | IS ) )? ( IntegerConstant )+ )+ ( IN AlphabetName )?

EnvironmentNameIsMnemonicNameClause	::=	( EnvironmentName ( IS )? MnemonicName ( SpecialNamesParagraphStatusPhrase )? | SpecialNamesParagraphStatusPhrase )

SpecialNamesParagraphStatusPhrase	::=	( ON ( STATUS )? ( IS )? Condition ( OFF ( STATUS )? ( IS )? Condition )? | OFF ( STATUS )? ( IS )? Condition ( ON ( STATUS )? ( IS )? Condition )? )

InputOutputSection	::=	INPUT_OUTPUT SECTION DOT ( InputOutputSectionParagraph )*

InputOutputSectionParagraph	::=	FileControlParagraph
|	IOControlParagraph

FileControlParagraph	::=	FILE_CONTROL ( ( DOT )? FileControlEntry )+ DOT

FileControlEntry	::=	SelectClause AssignClause ( FileControlClause )*

FileControlClause	::=	ReserveClause
|	OrganizationClause
|	PaddingCharacterClause
|	RecordDelimiterClause
|	AccessModeClause
|	AlternateRecordKeyClause
|	FileStatusClause
|	PasswordClause

SelectClause	::=	SELECT ( OPTIONAL )? FileName

AssignClause	::=	ASSIGN ( TO )? ( AssignmentName | Literal )

ReserveClause	::=	RESERVE IntegerConstant ( AREA | AREAS )

OrganizationClause	::=	( ORGANIZATION )? ( IS )? ( SequentialOrganizationClause | LineSequentialOrganizationClause | RelativeOrganizationClause | IndexedOrganizationClause )

SequentialOrganizationClause	::=	SEQUENTIAL

LineSequentialOrganizationClause	::=	LINE SEQUENTIAL

RelativeOrganizationClause	::=	SEQUENTIAL

IndexedOrganizationClause	::=	INDEXED

PaddingCharacterClause	::=	PADDING ( CHARACTER )? ( IS )? ( QualifiedDataName | Literal )

RecordDelimiterClause	::=	RECORD DELIMITER ( IS )? ( STANDARD_1 | IMPLICIT | AssignmentName )

AccessModeClause	::=	ACCESS ( MODE )? ( IS )? ( SequentialAccessMode | RandomAccessMode | DynamicAccessMode )

SequentialAccessMode	::=	SEQUENTIAL ( RelativeKeyClause )?

RandomAccessMode	::=	RANDOM ( RelativeKeyClause )?

DynamicAccessMode	::=	DYNAMIC ( RelativeKeyClause )?

RelativeKeyClause	::=	RELATIVE ( KEY )? ( IS )? QualifiedDataName

AlternateRecordKeyClause	::=	ALTERNATE RECORD ( KEY )? ( IS )? QualifiedDataName ( PasswordClause )? ( ( WITH )? DUPLICATES )?

PasswordClause	::=	PASSWORD ( IS )? DataName

FileStatusClause	::=	( FILE )? STATUS ( IS )? QualifiedDataName ( QualifiedDataName )?

IOControlParagraph	::=	I_O_CONTROL DOT ( IOControlClause ( ( DOT )? IOControlClause )* DOT )?

IOControlClause	::=	RerunClause
|	SameAreaClause
|	MultipleFileClause

RerunClause	::=	RERUN ( ON ( AssignmentName | FileName ) )? EVERY ( Rerun2 | IntegerConstant ( CLOCK_UNITS )? )

Rerun2	::=	IntegerConstant RECORDS
|	( END )? ( OF )? ( REEL | UNIT ) OF FileName

SameAreaClause	::=	SAME ( RECORD | SORT | SORT_MERGE ) ( AREA )? ( FOR )? ( FileName )+

MultipleFileClause	::=	MULTIPLE FILE ( TAPE )? ( CONTAINS )? FileName ( POSITION )? ( IntegerConstant )?

DataDivision	::=	DATA DIVISION DOT ( DataDivisionSection )*

DataDivisionSection	::=	FileSection
|	WorkingStorageSection
|	LinkageSection

FileSection	::=	FILE SECTION DOT ( FileAndSortDescriptionEntry ( DataDescriptionEntry )+ )*

FileAndSortDescriptionEntry	::=	( FD | SD ) FileName ( ( DOT )? FileAndSortDescriptionEntryClause )* DOT

FileAndSortDescriptionEntryClause	::=	ExternalClause
|	GlobalClause
|	BlockContainsClause
|	RecordContainsClause
|	LabelRecordsClause
|	ValueOfClause
|	DataRecordClause
|	LinageClause
|	CodeSetClause
|	ReportClause
|	RecordingModeClause

ExternalClause	::=	( IS )? EXTERNAL

GlobalClause	::=	( IS )? GLOBAL

BlockContainsClause	::=	BLOCK ( CONTAINS )? ( IntegerConstant TO )? IntegerConstant ( RECORDS | CHARACTERS )?

RecordContainsClause	::=	RECORD ( CONTAINS )? ( ( IntegerConstant TO )? IntegerConstant ( CHARACTERS )? | ( IS )? VARYING ( IN )? ( SIZE )? ( ( FROM )? IntegerConstant ( TO IntegerConstant )? CHARACTERS )? ( DEPENDING ( ON )? QualifiedDataName )? )

LabelRecordsClause	::=	LABEL ( RECORD ( IS )? | RECORDS ( ARE )? ) OMITTED
|	STANDARD
|	( DataName )+

ValueOfClause	::=	VALUE OF ( SystemName IS ( QualifiedDataName | Literal ) )+

DataRecordClause	::=	DATA ( RECORD ( IS )? | RECORDS ( ARE )? ) ( DataName )+

LinageClause	::=	LINAGE ( IS )? ( DataName | IntegerConstant ) ( LINES )? ( ( WITH )? FOOTING ( AT )? ( DataName | IntegerConstant ) | ( LINES )? ( AT )? TOP ( DataName | IntegerConstant ) | ( LINES )? ( AT )? BOTTOM ( DataName | IntegerConstant ) )*

RecordingModeClause	::=	RECORDING ( MODE )? ( IS )? Mode

CodeSetClause	::=	CODE_SET ( IS )? AlphabetName

ReportClause	::=	( REPORT ( IS )? | REPORTS ( ARE )? ) ( QualifiedDataName )+

DataDescriptionEntry	::=	( LevelNumber ( DataName | FILLER ) ( DataDescriptionEntryClause )* DOT | LEVEL_66 DataName RenamesClause DOT | LEVEL_77 DataName ( DataDescriptionEntryClause )* DOT | LEVEL_88 ConditionName ConditionValueClause DOT )

DataDescriptionEntryClause	::=	DataPictureClause
|	DataValueClause
|	DataUsageClause
|	DataRedefinesClause
|	DataExternalClause
|	DataGlobalClause
|	DataSignClause
|	DataOccursClause
|	DataSynchronizedClause
|	DataJustifiedClause
|	DataBlankWhenZeroClause

DataRedefinesClause	::=	REDEFINES DataName

DataBlankWhenZeroClause	::=	BLANK ( WHEN )? ( ZERO | ZEROS | ZEROES )

DataJustifiedClause	::=	( JUSTIFIED | JUST ) ( RIGHT )?

DataOccursClause	::=	OCCURS ( IntegerConstant TO )? IntegerConstant ( TIMES )? ( DEPENDING ( ON )? QualifiedDataName )? ( ( ASCENDING | DESCENDING ) ( KEY )? ( IS )? ( QualifiedDataName )+ )* ( INDEXED ( BY )? ( IndexName )+ )?

DataPictureClause	::=	( PICTURE | PIC ) ( IS )? PictureString

PictureString	::=	( PictureCurrency )? ( ( PictureChars )+ ( LPARENCHAR IntegerConstant RPARENCHAR )? )+ ( PicturePunctuation ( ( PictureChars )+ ( LPARENCHAR IntegerConstant RPARENCHAR )? )+ )?

PicturePunctuation	::=	SLASHCHAR
|	COMMACHAR
|	DOTCHAR
|	COLONCHAR

PictureCurrency	::=	DOLLARCHAR

PictureChars	::=	INTEGER
|	COBOL_WORD

DataExternalClause	::=	( IS )? EXTERNAL

DataGlobalClause	::=	( IS )? GLOBAL

DataUsageClause	::=	( USAGE ( IS )? )? ( BINARY | COMP | COMP_1 | COMP_2 | COMP_3 | COMP_4 | COMPUTATIONAL | COMPUTATIONAL_1 | COMPUTATIONAL_2 | COMPUTATIONAL_3 | COMPUTATIONAL_4 | DISPLAY | DISPLAY_1 | INDEX | PACKED_DECIMAL | POINTER )

DataSignClause	::=	( SIGN ( IS )? )? ( LEADING | TRAILING ) ( SEPARATE ( CHARACTER )? )?

DataSynchronizedClause	::=	( SYNCHRONIZED | SYNC ) ( ( LEFT | RIGHT ) )?

DataValueClause	::=	( VALUE ( IS )? | VALUES ( ARE )? ) ( Literal ( ( THROUGH | THRU ) Literal )? )+

ConditionValueClause	::=	DataValueClause

RenamesClause	::=	RENAMES QualifiedDataName ( ( THROUGH | THRU ) QualifiedDataName )?

WorkingStorageSection	::=	WORKING_STORAGE SECTION DOT ( DataDescriptionEntry )*

LinkageSection	::=	LINKAGE SECTION DOT ( DataDescriptionEntry )*

ProcedureDivision	::=	PROCEDURE DIVISION ( USING ( DataName )+ )? DOT ( Declaratives )? ProcedureBody

Declaratives	::=	DECLARATIVES DOT ( SectionHeader DOT UseStatement DOT Paragraphs )+ END DECLARATIVES DOT

ProcedureBody	::=	Paragraphs ( ProcedureSection )*

ProcedureSection	::=	SectionHeader DOT Paragraphs

SectionHeader	::=	SectionName SECTION ( IntegerConstant )?

Paragraphs	::=	( Sentence )* ( Paragraph )*

Paragraph	::=	ParagraphName DOT ( ExitStatement | AlteredGoto | ( Sentence )* )

Sentence	::=	StatementList DOT

StatementList	::=	( Statement )+

Statement	::=	( AcceptStatement | AddStatement | AlterStatement | CallStatement | CancelStatement | CloseStatement | ComputeStatement | ContinueStatement | DeleteStatement | DisplayStatement | DivideStatement | EntryStatement | EvaluateStatement | ExitProgramStatement | GobackStatement | GotoStatement | IfStatement | InitializeStatement | InspectStatement | MergeStatement | MoveStatement | MultiplyStatement | OpenStatement | PerformStatement | ReadStatement | ReleaseStatement | ReturnStatement | RewriteStatement | SearchStatement | SetStatement | SortStatement | StartStatement | StopStatement | StringStatement | SubtractStatement | UnstringStatement | WriteStatement )

AcceptStatement	::=	ACCEPT Identifier FROM ( MnemonicName | EnvironmentName | DATE | DAY | DAY_OF_WEEK | TIME )

AddStatement	::=	ADD ( ( CORRESPONDING | CORR ) Identifier TO Identifier | ( Identifier | Literal )+ ( TO ( Identifier ( ROUNDED )? )+ | ( TO Identifier )? GIVING ( Identifier ( ROUNDED )? )+ ) ) ( ( ON )? SIZE ERROR StatementList )? ( NOT ( ON )? SIZE ERROR StatementList )? ( END_ADD )?

AlteredGoto	::=	GO ( TO )? DOT

AlterStatement	::=	ALTER ( ProcedureName TO ( PROCEED TO )? ProcedureName )+

CallStatement	::=	CALL ( Identifier | Literal ) ( USING ( ( ( ( BY )? REFERENCE )? ( ( Identifier | ADDRESS OF Identifier | FileName ) )+ | ( BY )? CONTENT ( ( ( LENGTH OF )? Identifier | ADDRESS OF Identifier | Literal ) )+ ) )+ )? ( ( ON )? OVERFLOW StatementList )? ( ( ON )? EXCEPTION StatementList )? ( NOT ( ON )? EXCEPTION StatementList )? ( END_CALL )?

CancelStatement	::=	CANCEL ( Identifier | Literal )+

CloseStatement	::=	CLOSE ( FileName ( ( ( REEL | UNIT ) ( ( ( FOR )? REMOVAL | ( WITH )? NO REWIND ) )? | ( WITH )? ( NO REWIND | LOCK ) ) )? )+

ComputeStatement	::=	COMPUTE ( QualifiedDataName ( ROUNDED )? )+ ( EQUALCHAR | EQUAL ) ArithmeticExpression ( ( ON )? SIZE ERROR StatementList )? ( NOT ( ON )? SIZE ERROR StatementList )? ( END_COMPUTE )?

ContinueStatement	::=	CONTINUE

DeleteStatement	::=	DELETE FileName ( RECORD )? ( INVALID ( KEY )? StatementList )? ( NOT INVALID ( KEY )? StatementList )? ( END_DELETE )?

DisplayStatement	::=	DISPLAY ( Identifier | Literal )+ ( UPON ( MnemonicName | EnvironmentName ) )? ( ( WITH )? NO ADVANCING )?

DivideStatement	::=	DIVIDE ( QualifiedDataName | Literal ) ( INTO Literal ( GIVING ( Identifier ( ROUNDED )? )+ )? | INTO ( Identifier ( ROUNDED )? )+ | BY ( Identifier | Literal ) ( GIVING ( Identifier ( ROUNDED )? )+ )? ) ( REMAINDER Identifier )? ( ( ON )? SIZE ERROR StatementList )? ( NOT ( ON )? SIZE ERROR StatementList )? ( END_DIVIDE )?

EntryStatement	::=	ENTRY Literal ( USING ( Identifier )+ )?

EvaluateStatement	::=	EVALUATE EvaluateValue ( ALSO EvaluateValue )* ( ( WHEN EvaluatePhrase ( ALSO EvaluatePhrase )* )+ StatementList )+ ( WHEN OTHER StatementList )? ( END_EVALUATE )?

EvaluateValue	::=	( ArithmeticExpression | Identifier | Literal | Condition | TRUE | FALSE )

EvaluatePhrase	::=	( ANY | Condition | TRUE | FALSE | ( NOT )? ( Identifier | Literal | ArithmeticExpression ) ( ( THROUGH | THRU ) ( Identifier | Literal | ArithmeticExpression ) )? )

ExitStatement	::=	EXIT DOT

ExitProgramStatement	::=	EXIT PROGRAM

GobackStatement	::=	GOBACK

GotoStatement	::=	GO ( TO )? ( ProcedureName ( DEPENDING ( ON )? QualifiedDataName )? | MORE_LABELS )

IfStatement	::=	IF Condition ( THEN )? ( ( Statement )+ | NEXT SENTENCE ) ( ELSE ( ( Statement )+ | NEXT SENTENCE ) )? ( END_IF )?

InitializeStatement	::=	INITIALIZE ( Identifier )+ ( REPLACING ( ( ALPHABETIC | ALPHANUMERIC | NUMERIC | ALPHANUMERIC_EDITED | NUMERIC_EDITED | DBCS | EGCS ) ( DATA )? BY ( Identifier | Literal ) )+ )?

InspectStatement	::=	INSPECT QualifiedDataName ( TallyingPhrase | ConvertingPhrase | ReplacingPhrase )

TallyingPhrase	::=	TALLYING ( Identifier FOR ( CHARACTERS ( BeforeAfterPhrase )* | ( ALL | LEADING ) ( ( Identifier | Literal ) ( BeforeAfterPhrase )* )+ )+ )+ ( ReplacingPhrase )?

ConvertingPhrase	::=	CONVERTING ( Identifier | Literal ) TO ( Identifier | Literal ) ( BeforeAfterPhrase )*

ReplacingPhrase	::=	REPLACING ( CHARACTERS BY ( Identifier | Literal ) ( BeforeAfterPhrase )* | ( ALL | LEADING | FIRST ) ( ( Identifier | Literal ) BY ( Identifier | Literal ) ( BeforeAfterPhrase )* )+ )+

BeforeAfterPhrase	::=	( BEFORE | AFTER ) ( INITIAL )? ( Identifier | Literal )

MergeStatement	::=	MERGE FileName ( ( ON )? ( ASCENDING | DESCENDING ) ( KEY )? ( QualifiedDataName )+ )+ ( ( COLLATING )? SEQUENCE ( IS )? AlphabetName )? USING FileName ( FileName )+ ( OUTPUT PROCEDURE ( IS )? ProcedureName ( ( THROUGH | THRU ) ProcedureName )? | GIVING ( FileName )+ )

MoveStatement	::=	MOVE ( ( Identifier | Literal ) TO ( Identifier )+ | ( CORRESPONDING | CORR ) QualifiedDataName TO ( QualifiedDataName )+ )

MultiplyStatement	::=	MULTIPLY ( Identifier | Literal ) BY ( Identifier | Literal ) ( GIVING ( Identifier ( ROUNDED )? )+ )? ( ( ON )? SIZE ERROR StatementList )? ( NOT ( ON )? SIZE ERROR StatementList )? ( END_MULTIPLY )?

OpenStatement	::=	OPEN ( INPUT ( FileName ( ( REVERSED | ( WITH )? NO REWIND ) )? )+ | OUTPUT ( FileName ( ( WITH )? NO REWIND )? )+ | I_O ( FileName )+ | EXTEND ( FileName )+ )+

PerformStatement	::=	PERFORM ( PerformProcedureScopeClause ( PerformFlavour )? | PerformFlavour ( StatementList END_PERFORM | PerformProcedureScopeClause ) )

PerformFlavour	::=	PerformTimeClause
|	PerformUntilClause
|	PerformVaryingWithTestClause

PerformVaryingWithTestClause	::=	( PerformTestPositionClause PerformVaryingClause | PerformVaryingClause ( PerformTestPositionClause )? )

PerformVaryingClause	::=	VARYING QualifiedDataName FROM ( Identifier | Literal ) BY ( Identifier | Literal ) PerformUntilClause

PerformUntilClause	::=	UNTIL Condition

PerformTestPositionClause	::=	( WITH )? TEST ( BEFORE | AFTER )

PerformProcedureScopeClause	::=	ProcedureName ( ( THROUGH | THRU ) ProcedureName )?

PerformTimeClause	::=	( QualifiedDataName | IntegerConstant ) TIMES

ReadStatement	::=	READ FileName ( NEXT )? ( RECORD )? ( INTO QualifiedDataName )? ( KEY ( IS )? QualifiedDataName )? ( INVALID ( KEY )? StatementList )? ( NOT INVALID ( KEY )? StatementList )? ( ( AT )? END StatementList )? ( NOT ( AT )? END StatementList )? ( END_READ )?

ReleaseStatement	::=	RELEASE RecordName ( FROM QualifiedDataName )?

ReturnStatement	::=	RETURN FileName ( RECORD )? ( INTO QualifiedDataName )? ( AT )? END StatementList ( NOT ( AT )? END StatementList )? ( END_RETURN )?

RewriteStatement	::=	REWRITE RecordName ( FROM QualifiedDataName )? ( INVALID ( KEY )? StatementList )? ( NOT INVALID ( KEY )? StatementList )? ( END_REWRITE )?

SearchStatement	::=	SEARCH ( ALL )? QualifiedDataName ( VARYING QualifiedDataName )? ( ( AT )? END StatementList )? ( WHEN Condition ( StatementList | NEXT SENTENCE ) )+ ( END_SEARCH )?

SetStatement	::=	SET QualifiedDataName ( TO ( Identifier | TRUE | FALSE | ON | OFF | Literal ) | ( UP | DOWN ) ( BY )? ( Identifier | Literal ) )

SortStatement	::=	SORT FileName ( ( ON )? ( ASCENDING | DESCENDING ) ( KEY )? ( QualifiedDataName )+ )+ ( ( WITH )? DUPLICATES ( IN )? ( ORDER )? )? ( ( COLLATING )? SEQUENCE ( IS )? AlphabetName )? ( USING ( FileName )+ | INPUT PROCEDURE ( IS )? ProcedureName ( ( THROUGH | THRU ) ProcedureName )? ) ( GIVING ( FileName )+ | OUTPUT PROCEDURE ( IS )? ProcedureName ( ( THROUGH | THRU ) ProcedureName )? )

StartStatement	::=	START FileName ( KEY ( IS )? ( EQUAL ( TO )? | EQUALCHAR | GREATER ( THAN )? | MORETHANCHAR | NOT LESS ( THAN )? | NOT LESSTHANCHAR | GREATER ( THAN )? OR EQUAL ( TO )? | MORETHANOREQUAL ) QualifiedDataName )? ( INVALID ( KEY )? StatementList )? ( NOT INVALID ( KEY )? StatementList )? ( END_START )?

StopStatement	::=	STOP ( RUN | Literal )

StringStatement	::=	STRING ( ( QualifiedDataName | Literal )+ DELIMITED ( BY )? ( Identifier | Literal | SIZE ) )+ INTO Identifier ( ( WITH )? POINTER QualifiedDataName )? ( ( ON )? OVERFLOW StatementList )? ( NOT ( ON )? OVERFLOW StatementList )? ( END_STRING )?

SubtractStatement	::=	SUBTRACT ( ( Identifier | Literal )+ FROM ( Identifier ( ROUNDED )? )+ | ( Identifier | Literal ) FROM Identifier ( ROUNDED )? GIVING Identifier | ( CORRESPONDING | CORR ) QualifiedDataName FROM QualifiedDataName ) ( ( ON )? SIZE ERROR StatementList )? ( NOT ( ON )? SIZE ERROR StatementList )? ( END_SUBTRACT )?

UnstringStatement	::=	UNSTRING QualifiedDataName ( DELIMITED ( BY )? ( ALL )? ( Identifier | Literal ) ( OR ( ALL )? ( Identifier | Literal ) )* )? INTO ( Identifier ( DELIMITER ( IN )? Identifier )? ( COUNT ( IN )? Identifier )? )+ ( ( WITH )? POINTER QualifiedDataName )? ( TALLYING ( IN )? QualifiedDataName )? ( ( ON )? OVERFLOW StatementList )? ( NOT ( ON )? OVERFLOW StatementList )? ( END_UNSTRING )?

UseStatement	::=	USE ( ( FOR )? DEBUGGING ( ON )? ( ( ProcedureName )+ | ALL PROCEDURES ) | ( GLOBAL )? AFTER ( STANDARD )? ( ( EXCEPTION | ERROR ) | ( ( BEGINNING | ENDING ) )? ( ( FILE | REEL | UNIT ) )? LABEL ) PROCEDURE ( ON )? ( ( FileName )+ | INPUT | OUTPUT | I_O | EXTEND ) )

WriteStatement	::=	WRITE RecordName ( FROM QualifiedDataName )? ( AdvancingPhrase )? ( ( AT )? ( END_OF_PAGE | EOP ) StatementList )? ( NOT ( AT )? ( END_OF_PAGE | EOP ) StatementList )? ( INVALID ( KEY )? StatementList )? ( NOT INVALID ( KEY )? StatementList )? ( END_WRITE )?

AdvancingPhrase	::=	( BEFORE | AFTER ) ( ADVANCING )? ( PAGE | ( Identifier | IntegerConstant ) ( ( LINE | LINES ) )? | MnemonicName )